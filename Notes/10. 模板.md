# 模板

# 1. 为什么要定义模板？
1. 简化代码，少写代码
2. 可以解决严格性与灵活性的冲突
3. 强类型语言：C/C++/Java等，有严格的类型检查
弱类型程序语言设计：js/python等，虽然也有类型，但是在使用的时候不知道变量具体类型

# 2. 模板的定义
```c++
template <typename T1, typename T2，...>
template <class T1, class T2，...>
//模板参数列表中typename与class的含义是完全一样
```

# 3. 模板的类型
函数模板与类模板

## 3.1 函数模板
```c++
template <typename T>
T add(T x, T y)
{
}
```
### 3.1.1 实例化：隐式实例化与显示实例化
```c++
add(ia, ib);//隐式实例化，没有明确说明类型，靠编译器推导
add<double>(da, db);//显示实例化，编译器无需推导
```

### 3.1.2 函数模板、普通函数的关系
1. 函数模板与普通函数可以进行重载
2. 普通函数优先于函数模板执行
3. 函数模板与函数模板之间也可以进行重载

### 3.1.3 模板头文件与实现文件
模板不能写成头文件与实现文件形式，不能将声明与实现分开。如果一定要分开，可以在头文件中#include实现文件

### 3.1.4 模板的特化：偏特化与全特化
全特化：将模板参数列表中的参数全部以特殊版本的形式写出来；
偏特化（部分特化）：模板参数列表中的参数类型，至少有一个没有特化出来。

### 3.1.5 函数模板的参数类型
模板参数可以设置默认值
1. 类型参数：如 class T 
2. 非类型参数：常量表达式、整型
```c++
template <typename T = int, short kMin = 10>
T multiply(T x, T y)
{
    return x * y * kMin;
}
```

### 3.1.6 成员函数模板
类的成员函数也可以设置为模板
```c++
class Point
{
public:
    template <typename T = int>
    T func()
    {
        return (T)_dx;
    }
private:
    double _dx;
    double _dy;
};
```

## 3.2 类模板
```c++
template <typename T>
class Stack
{
private:
    T *_data;
};
```

# 4 可变模板参数
C++11新增的最强大的特性之一，对参数进行了高度的泛化，能表示0到任意个数、任意类型的参数。

## 4.1 模板参数包
template<typename… Args> 
class tuple;
tuple 是元组的意思，其模板参数就是模板参数包
Args标识符的左侧使用了省略号,在C++11中Args被称为“模板参数包”,表示可以接受任意多个参数作为模板参数,编译器将多个模板参数打包成“单个”的模板参数包.

## 4.2 函数参数包
template<typename…T> 
void f(T…args)
args就是函数参数包
C++11标准中，要求函数参数包必须唯一，且是函数的最后一个参数;
当使用参数包时，省略号位于参数名称的右侧，表示立即展开该参数，这个过程也被称为解包

## 4.3 可变模板参数的优势
1、参数个数，推导的时候就已经知道了
2、参数类型，推导的时候也已经确定了
